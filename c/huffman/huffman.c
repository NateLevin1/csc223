#include <stdio.h>
#include <stdlib.h>
#include "pqueue.h"
#define BYTE_TO_BINARY_PATTERN "%c%c%c%c%c%c%c%c"
#define BYTE_TO_BINARY(byte)  \
  ((byte) & 0x80 ? '1' : '0'), \
  ((byte) & 0x40 ? '1' : '0'), \
  ((byte) & 0x20 ? '1' : '0'), \
  ((byte) & 0x10 ? '1' : '0'), \
  ((byte) & 0x08 ? '1' : '0'), \
  ((byte) & 0x04 ? '1' : '0'), \
  ((byte) & 0x02 ? '1' : '0'), \
  ((byte) & 0x01 ? '1' : '0') 

// generated by getconsts.py
#define ALPHABET_SIZE 71
const char alphabet[ALPHABET_SIZE] = "30Z[]_XJV()*PUFzKGQBL\"YNqjRxCOED;M?S:WH!TA-Iv.kbpmfyc,wg'u\nldrsinhoate ";
const int freq[ALPHABET_SIZE] = { 1, 1, 1, 2, 2, 4, 4, 8, 42, 56, 56, 60, 65, 66, 74, 77, 82, 83, 84, 91, 98, 113, 114, 120, 125, 138, 140, 144, 145, 176, 188, 192, 194, 200, 202, 218, 233, 237, 284, 450, 472, 638, 669, 733, 804, 978, 1076, 1384, 1459, 1907, 1927, 2148, 2254, 2418, 2438, 2448, 2871, 3402, 3597, 4618, 4739, 5298, 6282, 6781, 6896, 7090, 7970, 8153, 10216, 13387, 28917, };

char* read_file(char* path);
void symbol_to_code_recursive(TreeNode* node, int code[], int so_far);

int main() {
    printf("Compressing aliceinwonderland.txt...\n");

    printf("Frequencies:\n");
    for (int i = 0; i < ALPHABET_SIZE; i++) {
        printf("%c: %d\n", alphabet[i], freq[i]);
    }

    Node* pq = NULL;

    // Create a leaf node for each symbol and add it to the priority queue.
    for (int i = 0; i < ALPHABET_SIZE; i++) {
        sortedAppend(&pq, make_pq_node(alphabet[i], freq[i]));
    }

    // * The below algorithm is from https://en.wikipedia.org/wiki/Huffman_coding#Informal_description
    // while there is more than one node in the queue:
    while (pq->next != NULL) {
        // remove the two nodes of lowest weight from the queue
        Node* first = pq;
        pq = pq->next;
        Node* second = pq;
        pq = pq->next;

        // create a new internal node with these two nodes as children and with weight equal to the sum of the two nodes' probabilities.
        Node* internal = make_pq_node('\0', first->weight + second->weight);
        internal->node->left = first->node;
        internal->node->right = second->node;

        // add the new node to the queue.
        sortedAppend(&pq, internal);
    }

    // the remaining node is the root node and the tree is complete.
    TreeNode* tree = pq->node;

    // traverse the tree to generate mapping from symbol to binary code
    int code[255];
    symbol_to_code_recursive(tree, code, 0);

    // print out code table
    printf("Code table:\n");
    for (int i = 0; i < ALPHABET_SIZE; i++) {
        printf("%c: "BYTE_TO_BINARY_PATTERN"\n", alphabet[i], BYTE_TO_BINARY(code[alphabet[i]]));
    }

    char* file = read_file("aliceinwonderland.txt");

}

void symbol_to_code_recursive(TreeNode* node, int code[], int so_far) {
    if (node->left == NULL && node->right == NULL) {
        // is a leaf node
        code[node->data] = so_far;
    } else {
        // is an internal node
        so_far <<= 1;
        if (node->left != NULL) symbol_to_code_recursive(node->left, code, so_far | 0);
        if (node->right != NULL) symbol_to_code_recursive(node->right, code, so_far | 1);
    }
}

char* read_file(char* path) {
    FILE* f = fopen(path, "r");
    char* buffer;
    int length;

    fseek(f, 0, SEEK_END);
    length = ftell(f);
    fseek(f, 0, SEEK_SET);
    buffer = malloc(length);
    if (buffer)
    {
        fread(buffer, 1, length, f);
    }
    fclose(f);

    return buffer;
}